{capture assign="page_title"}Pagination | API{/capture}
{include file="inc_head.txt"}

<div class="container">
{include file="inc_api_header.txt" title="API Pagination" subtitle=$subtitle subtitle_isescaped=1}
</div>

<div class="container" id="history">

<h3>A short miserable history (of pagination)</h3>

<p>Pagination shouldn't be this complicated. But it is. Because databases, after all these years, are still complicated beasts.</p>

<p>Databases have always been about trade-offs and no two databases are the same (so no two sets of trade-offs are the same either). The really short version is that some databases can't tell you exactly how many results there are for a given query. Some databases can tell you how many results there are but can't or won't return results past a certain limit. Other databases can do both but only if you use something called a <code>cursor</code> for pagination rather than the traditional <code>offset</code> and <code>limit</code> model (as in "return the next 5 of 50 results starting from postion 20").</p>

<p><span class="hey-look">{$cfg.site_name|@escape}</span> uses different databases for different purposes, because there is still isn't a single all-purpose database that can do everything, so we also have to account for multiple different pagination models. We've identified four overlapping models (plain, cursor, mixed and next-query) each of which are described in detail below.</p>

<p>If you don't really care and just want to get started <a href="#next-query">you should skip ahead to the documentation for next-query pagination</a>.</p>

</div>

<div class="container" id="plain">
<h3>Plain pagination</h3>

<p>Plain pagination assumes that we know how many results a query yields and that we can fetch any set of results at any given offset.</p>

<p>For example, let's say you wanted to use the API to fetch all the places with a variant name containing the word <code>Paris</code> in sets of five. The API will respond with something like this:</p>

<pre>{literal}
{
	"results": [ ... ],
	"next_query": "method=whosonfirst.places.search&alt=Paris&per_page=5&page=2",
	<strong>"total": 7</strong>,
	<strong>"page": 1</strong>,
	<strong>"per_page": 5</strong>,
	<strong>"pages": 2</strong>,
	"cursor": null,
	"stat": "ok"
}
{/literal}</pre>

<p>It's pretty straightforward. There are seven results (<code>total</code>) and this is the first of two pages worth of results (<code>page</code> and <code>pages</code>, respectively). You might already be wondering about the <code>next_query</code> property but <a href="#next-query">we'll get to that shortly</a>.</p>

</div>

<div class="container" id="cursor">
<h3>Cursor-based pagination</h3>

<p>Cursor-based pagination is necessary when a database can't or won't tell you how many results there are for a query. This it means you will need to pass the same query to the database over and over again for as long as the database returns a <code>cursor</code> which is like a secret hint that <em>only the database understands</em> indicating where the next set of results live.</p>

<p>For example, let's say you wanted to use the API to fetch all the venues near the <a href="https://whosonfirst.mapzen.com/spelunker/id/420571601/">Smithsonian Cooper Hewitt Design Museum</a> in sets of ten. The API will respond with something like this:</p>

<pre>{literal}
{
	"results": [ ... ],
	"next_query": "method=whosonfirst.places.getNearby&latitude=40.784165&longitude=-73.958110&placetype=venue&cursor={CURSOR}",
	"per_page": 10,
	<strong>"cursor": {CURSOR}</strong>,
	"stat": "ok"
}
{/literal}</pre>

<p>In order to fetch the next set of results you would include a <code>cursor={literal}{CURSOR}{/literal}</code> parameter in your request, rather than a <code>page={literal}{PAGE_NUMBER}{/literal}</code> parameter like you would with plain pagination. Databases, amirite?</p>

</div>

<div class="container" id="mixed">
<h3>Mixed pagination</h3>

<p>This is where it gets fun.</p>

<p>Please write me.</p>

<p>For example, let's say you wanted to use the API to fetch all the <code>microhoods</code> in sets of five. The API will respond with something like this:</p>

<pre>{literal}
{
	"results": [ ... ],
	"next_query": "method=whosonfirst.places.search&placetype=microhood&page=2",
	<strong>"total": 186</strong>,
	<strong>"page": 1</strong>,
	"per_page": 5,
	<strong>"pages": 38</strong>,
	<strong>"cursor": null</strong>,
	"stat": "ok"
}
{/literal}</pre>

<p>But if you then asked the API to fetch all the <code>neighbourhoods</code>, again in sets of five, the API will respond with something like this:</p>

<pre>{literal}
{
	"results": [ ... ],
	"next_query": "method=whosonfirst.places.search&placetype=neighbourhood&cursor={CURSOR}",
	<strong>"total": 81065</strong>,
	<strong>"page": null</strong>,
	<strong>"pages": 16213</strong>,
	"per_page": 5,
	<strong>"cursor": "{CURSOR}"</strong>,
	"stat": "ok"
}
{/literal}</pre>

</div>

<div class="container" id="next-query">
<h3>Next-query-based pagination</h3>

<p>Next-query based pagination is an attempt to hide most of the implentation details from consumers and provide a simple "here-do-this-next" style pagination interface, instead.</p>

<p>For example, let's say you wanted to use the API to fetch all the localities (there are over 200, 000 of them) in sets of five. That will require 40, 000 API requests but that's your business. The API will respond with a <code>next_query</code> parameter, something like this:</p>

<pre>{literal}
{
	"results": [ ... ],
	<strong>"next_query": "method=whosonfirst.places.search&placetype=locality&per_page=5&cursor={CURSOR}"</strong>,
	"total": 208214,
	"page": null,
	"pages": 41643,
	"per_page": 5,
	<strong>"cursor": "{CURSOR}"</strong>,
	"stat": "ok"
}
{/literal}</pre>

<p>There are a few things to note about the <code>next_query</code> property:</p>

<ul>
	<li>It contains a URL-encoded query string with the parameters to pass to the API retrieve the <em>next</em> set of results for your query.</li>
	<li>When it is empty (or <code>null</code>) that means there are no more results.</li>
	<li>It <em>does not</em> contain any user-specific access tokens or API keys &#8212; you will need to add those yourself.</li>
	<li>It <em>does not</em> contain any host or endpoint specific information  &#8212; you will need to add that yourself.</li>
	<li>You may want or need to decode the query string in order to append additional parameters (like authentication) and to handle how those parameters are sent along to the API. For example, whether the method is invoked using HTTP's <code>GET</code> or <code>POST</code> method or whether parameters should be <code>multipart/mime</code> encoded or not. And so on.</li>
</ul>

<p>This type of pagination is not ideal but strives to be a reasonable middle-ground that is not too onerous to implement.</p>

</div>

{include file="inc_foot.txt"}
